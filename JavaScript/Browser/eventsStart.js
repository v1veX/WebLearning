// event handlers

// in html
// on<eventName>="function()"
// <input value="Нажми меня" onclick="alert('Клик!')" type="button">

// DOM property
elem.onclick = function() {
    alert('Спасибо');
};
// Убрать обработчик можно назначением elem.onclick = null

// this в обработчике ссылается на текущий элемент, то есть на тот, на котором, назначен обработчик

// addEventListener
element.addEventListener(event, handler, [options]);

/* event
Имя события, например "click". */
/* handler
Ссылка на функцию-обработчик. */
/* options
Дополнительный объект со свойствами:
once: если true, тогда обработчик будет автоматически удалён после выполнения.
capture: фаза, на которой должен сработать обработчик
passive: если true, то указывает, что обработчик никогда не вызовет preventDefault()*/

element.removeEventListener(event, handler, [options]); // удаление обработчика

// DOMContentLoaded - обработчик для этого события можно назначить только через addEventListener

// объект события

elem.onclick = function(event) {  // добавляем event
    // вывести тип события, элемент и координаты клика
    alert(event.type + " на " + event.currentTarget);
    alert("Координаты: " + event.clientX + ":" + event.clientY);
};

// event.currentTarget (=this) - элемент, на котором сработал обработчик события 
// event.target – самый глубокий элемент, на котором произошло событие

// Объект-обработчик: handleEvent
// Мы можем назначить обработчиком объект при помощи addEventListener. В этом случае, когда происходит событие, вызывается метод объекта handleEvent.


// Всплытие событий

// Почти все события всплывают. Т.е. если у элемента есть обработчик, то клик по любому из его дочерних элементов вызовет обработчик

event.stopPropagation(); // останавливает всплытие события
event.stopImmediatePropagation(); // останавливает всплытие события и отменяет вызов оставшихся обработчиков на элементе

// Погружение событий

element.addEventListener(event, handler, true); // вызовет обработчик после стадии погружения


// Делегирование событий

// его суть в том, что мы вешаем один обработчик событий на контейнер, а не на каждый его элемент
// экономим память и упрощаем инициализацию

// Алгоритм:

// 1. Вешаем обработчик на контейнер
// 2. В обработчике проверяем исходный элемент event.target
// 3. Если событие произошло внутри нужного нам элемента, то обрабатываем его